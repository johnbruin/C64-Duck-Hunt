#importonce

.macro irq_enter()
{
    pha
    txa
    pha
    tya
    pha
}

.macro irq_init()
{
    lda #$35                // no basic, no kernal
    sta $01

    lda #$7f
    sta $dc0d               //disable timer interrupts which can be generated by the two CIA chips
    sta $dd0d               //the kernal uses such an interrupt to flash the cursor and scan the keyboard, so we better
                            //stop it.
    lda $dc0d               //by reading this two registers we negate any pending CIA irqs.
    lda $dd0d               //if we don't do this, a pending CIA irq might occur after we finish setting up our irq.
                            //we don't want that to happen.
    
    lda #$01                //this is how to tell the VICII to generate a raster interrupt
    sta $d01a
}

.macro irq_setup(irq_vector, rasterline) 
{
    ldx #>irq_vector
    ldy #<irq_vector
    stx $ffff
    sty $fffe
    lda #rasterline
    sta $d012

    .if (rasterline > 255) {
		// bit 7 of $d011 is RST8
		lda $d011
		ora #$80
		sta $d011
	}
	else {
		lda $d011
		and #$7f
		sta $d011
	}
}

.macro irq_next(irq_vector, rasterline) 
{
    :irq_setup(irq_vector, rasterline)    
    lda #$ff   //this is the orthodox and safe way of clearing the interrupt condition of the VICII.
    sta $d019 
    :irq_exit()
}

.macro irq_exit() 
{
    pla
    tay
    pla
    tax
    pla
    rti
}

.macro waste_cycles(n) 
{
    .var nops = floor(n/2)
    .var rem = n&1

    .var c = n
    .if (rem == 0) {
        .for (var i = 0; i < nops; i++) {
            nop
            .eval c -= 2
        }
    } else {
        .for (var i = 0; i < nops-1; i++) {
            nop
            .eval c -= 2
        }
        bit $fe
        .eval c -= 3
    }
    .if (c != 0) {
        .error "assert"
    }
}

.macro irq_stabilize() 
{
    //«»«»«»«»«»«»«»«»«»«»«»«»«»«»«»«»«»«»«»«»«»«»«»«»«»
    // Raster Stabilizing Code
    //«»«»«»«»«»«»«»«»«»«»«»«»«»«»«»«»«»«»«»«»«»«»«»«»«»
        // A Raster Compare IRQ is triggered on cycle 0 on the current $d012 line
        // The MPU needs to finish it's current OP code before starting the Interrupt Handler,
        // meaning a 0 -> 7 cycles delay depending on OP code.
        // Then a 7 cycle delay is spendt invoking the Interrupt Handler (Push SR/PC to stack++)
        // Then 13 cycles for storing registers (pha, txa, pha, tya, pha)

        // CYCLECOUNT: [20 -> 27] cycles after Raster IRQ occurred.

        // Set up Wedge IRQ vector
        lda #<WedgeIRQ
        sta $fffe
        lda #>WedgeIRQ
        sta $ffff

        // Set the Raster IRQ to trigger on the next Raster line
        inc $d012

        // Acknowlege current Raster IRQ
        lda #$ff
        sta $d019

        // Store current Stack Pointer (will be messed up when the next IRQ occurs)
        tsx

        // Allow IRQ to happen (Remeber the Interupt flag is set by the Interrupt Handler).
        cli

        // Execute NOPs untill the raster line changes and the Raster IRQ triggers
        nop
        nop
        nop
        nop
        nop
        nop
        nop
        nop
        // Add one extra nop for 65 cycle NTSC machines

        // CYCLECOUNT: [64 -> 71]

    WedgeIRQ:
        // At this point the next Raster Compare IRQ has triggered and the jitter is max 1 cycle.
        // CYCLECOUNT: [7 -> 8] (7 cycles for the interrupt handler + [0 -> 1] cycle Jitter for the NOP)

        // Restore previous Stack Pointer (ignore the last Stack Manipulation by the IRQ)
        txs

        // PAL-63  // NTSC-64    // NTSC-65
        //---------//------------//-----------
        ldx #$08   // ldx #$08   // ldx #$09
        dex        // dex        // dex
        bne *-1    // bne *-1    // bne *-1
        bit $00    // nop
                // nop

        // Check if $d012 is incremented and rectify with an aditional cycle if neccessary
        lda $d012
        cmp $d012  // <- critical instruction (ZERO-Flag will indicate if Jitter = 0 or 1)

        // CYCLECOUNT: [61 -> 62] <- Will not work if this timing is wrong

        // cmp $d012 is originally a 5 cycle instruction but due to piplining tech. the
        // 5th cycle responsible for calculating the result is executed simultaniously
        // with the next OP fetch cycle (first cycle of beq *+2).

        // Add one cycle if $d012 wasn't incremented (Jitter / ZERO-Flag = 0)
        beq *+2

        // Stable code  
}